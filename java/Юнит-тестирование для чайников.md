# Юнит-тестирование для чайников

> Даже если вы никогда в жизни не думали, что занимаетесь тестированием, вы это делаете. Вы собираете свое приложение, нажимаете кнопку и проверяете, соответствует...

Даже если вы никогда в жизни не думали, что занимаетесь тестированием, вы это делаете. Вы собираете свое приложение, нажимаете кнопку и проверяете, соответствует ли полученный результат вашим ожиданиям. Достаточно часто в приложении можно встретить формочки с кнопкой “Test it” или классы с названием _TestController_ или _MyServiceTestClient_.

![](https://habrastorage.org/storage2/6da/5c9/f6d/6da5c9f6d05c82a919b8cdcfa00e0b9b.png)

То что вы делаете, называется _интеграционным тестированием_. Современные приложения достаточно сложны и содержат множество зависимостей. Интеграционное тестирование проверяет, что несколько компонентов системы работают вместе правильно.

Оно выполняет свою задачу, но сложно для автоматизации. Как правило, тесты требуют, чтобы вся или почти вся система была развернута и сконфигурирована на машине, на которой они выполняются. Предположим, что вы разрабатываете web-приложение с UI и веб-сервисами. Минимальная комплектация, которая вам потребуется: браузер, веб-сервер, правильно настроенные веб-сервисы и база данных. На практике все еще сложнее. Разворачивать всё это на билд-сервере и всех машинах разработчиков?

We need to go deeper
--------------------

![](https://habrastorage.org/storage2/5c0/1c5/99f/5c01c599f95b6ee0edf77494908860a9.jpg)  
Давайте сначала спустимся на предыдущий уровень и убедимся, что наши компоненты работают правильно по-отдельности.

Обратимся к википедии:

> **Модульное тестирование**, или **юнит-тестирование** (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.
> 
> Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.

![](https://habrastorage.org/storage2/ec3/825/c7f/ec3825c7f0710f9fed6814c89b794ded.jpg)

Таким образом, юнит-тестирование – это первый бастион на борьбе с багами. За ним еще интеграционное, приемочное и, наконец, ручное тестирование, в том числе «свободный поиск».

Нужно ли все это вам? С моей точки зрения ответ: «не всегда».

Не нужно писать тесты, если
---------------------------

  

*   Вы делаете простой сайт-визитку из 5 статических html-страниц и с одной формой отправки письма. На этом заказчик, скорее всего, успокоится, ничего большего ему не нужно. Здесь нет никакой особенной логики, быстрее просто все проверить «руками»
*   Вы занимаетесь рекламным сайтом/простыми флеш-играми или баннерами – сложная верстка/анимация или большой объем статики. Никакой логики нет, только представление
*   Вы делаете проект для выставки. Срок – от двух недель до месяца, ваша система – комбинация железа и софта, в начале проекта не до конца известно, что именно должно получиться в конце. Софт будет работать 1-2 дня на выставке
*   Вы всегда пишете код без ошибок, обладаете идеальной памятью и даром предвидения. Ваш код настолько крут, что изменяет себя сам, вслед за требованиями клиента. Иногда код объясняет клиенту, что его требования — ~гов~ не нужно реализовывать

В первых трех случаях по объективным причинам (сжатые сроки, бюджеты, размытые цели или очень простые требования) вы не получите выигрыша от написания тестов.

Последний случай рассмотрим отдельно. Я знаю только одного такого человека, и если вы не узнали себя на фото ниже, то у меня для вас плохие новости.

![](https://habrastorage.org/storage2/635/68c/356/63568c35676c4d929422ec8e42dd3563.jpg)

Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно быть переписанным с нуля
-----------------------------------------------------------------------------------------------------------

![](https://habrastorage.org/storage2/ee9/ab0/40f/ee9ab040f988cde943d001c819e8c08c.png)

В своей практике я много раз встречался с проектами старше года. Они делятся на три категории:

*   **Без покрытия тестами.** Обычно такие системы сопровождаются спагетти-кодом и уволившимися ведущими разработчиками. Никто в компании не знает, как именно все это работает. Да и что оно в конечном итоге должно делать, сотрудники представляют весьма отдаленно.
*   **С тестами, которые никто не запускает и не поддерживает.** Тесты в системе есть, но что они тестируют, и какой от них ожидается результат, неизвестно. Ситуация уже лучше. Присутствует какая-никакая архитектура, есть понимание, что такое слабая связанность. Можно отыскать некоторые документы. Скорее всего, в компании еще работает главный разработчик системы, который держит в голове особенности и хитросплетения кода.
*   **С серьезным покрытием. Все тесты проходят.** Если тесты в проекте действительно запускаются, то их много. Гораздо больше, чем в системах из предыдущей группы. И теперь каждый из них – атомарный: один тест проверяет только одну вещь. Тест является спецификацией метода класса, контрактом: какие входные параметры ожидает этот метод, и что остальные компоненты системы ждут от него на выходе. Таких систем гораздо меньше. В них присутствует актуальная спецификация. Текста немного: обычно пара страниц, с описанием основных фич, схем серверов и _getting started guide’ом_. В этом случае проект не зависит от людей. Разработчики могут приходить и уходить. Система надежно протестирована и сама рассказывает о себе путем тестов.

Проекты первого типа – крепкий орешек, с ними работать тяжелее всего. Обычно их рефакторинг по стоимости равен или превышает переписывание с нуля.

Почему есть проекты второго типа?
---------------------------------

Коллеги из _ScrumTrek_ уверяют, что всему виной темная сторона кода и властелин [Дарт Автотестиус](http://habrahabr.ru/company/scrumtrek/blog/168485/). Я убежден, что это очень близко к правде. Бездумное написание тестов **не только не помогает, но вредит проекту**. Если раньше у вас был один некачественный продукт, то написав тесты, не разобравшись в этой теме, вы получите два. И удвоенное время на сопровождение и поддержку.

Для того чтобы темная сторона кода не взяла верх, нужно придерживаться **следующих основных правил**.  
Ваши тесты должны:

*   Быть достоверными
*   Не зависеть от окружения, на котором они выполняются
*   Легко поддерживаться
*   Легко читаться и быть простыми для понимания (даже новый разработчик должен понять **что именно** тестируется)
*   Соблюдать единую конвенцию именования
*   Запускаться регулярно в автоматическом режиме

Чтобы достичь выполнения этих пунктов, нужны терпение и воля. Но давайте по порядку.

### Выберите логическое расположение тестов в вашей VCS

Только так. Ваши тесты должны быть частью контроля версий. В зависимости от типа вашего решения, они могут быть организованы по-разному. Общая рекомендация: если приложение монолитное, положите все тесты в папку Tests; если у вас много разных компонентов, храните тесты в папке каждого компонента.

### Выберите способ именования проектов с тестами

Одна из лучших практик: добавьте к каждому проекту его собственный тестовый проект.  
У вас есть части системы <PROJECT\_NAME>.Core, <PROJECT\_NAME>.Bl и <PROJECT\_NAME>.Web? Добавьте еще <PROJECT\_NAME>.Core.Tests, <PROJECT\_NAME>.Bl.Tests и <PROJECT\_NAME>.Web.Tests.

У такого способа именования есть дополнительный сайд-эффект. Вы сможете использовать паттерн \*.Tests.dll для запуска тестов на билд-сервере.

### Используйте такой же способ именования для тестовых классов

У вас есть класс ProblemResolver? Добавьте в тестовый проект ProblemResolverTests. Каждый тестирующий класс должен тестировать только одну сущность. Иначе вы очень быстро скатитесь

~в унылое го~

во второй тип проектов (с тестами, которые никто не запускает).

### Выберите «говорящий» способ именования методов тестирующих классов

_TestLogin_ – не самое лучшее название метода. Что именно тестируется? Каковы входные параметры? Могут ли возникать ошибки и исключительные ситуации?

На мой взгляд, лучший способ именования методов такой: _\[Тестируемый метод\]\_\[Сценарий\]\_\[Ожидаемое поведение\]_.  
Предположим, что у нас есть класс Calculator, а у него есть метод Sum, который (привет, Кэп!) должен складывать два числа.  
В этом случае наш тестирующий класс будет выглядеть так:

    сlass CalculatorTests
    {
            public void Sum_2Plus5_7Returned()
            {
     	    // …
            }
    }
    

Такая запись понятна без объяснений. Это спецификация к вашему коду.

### Выберите тестовый фреймворк, который подходит вам

Вне зависимости от платформы не стоит писать велосипеды. Я видел много проектов, в которых автоматические тесты (в основном, не юнит, а приемочные) запускались из консольного приложения. Не надо этого делать, все уже сделано за вас.

Уделите чуть больше внимания обзору фреймворков. Например, многие .NET разработчики используют MsTest только потому, что он входит в поставку студии. Мне гораздо больше по душе NUnit. Он не создает лишних папок с результатами тестов и имеет поддержку параметризированного тестирования. Я могу так же легко запускать мои тесты на NUnit с помощью Решарпера. Кому-то понравится элегантность xUnit’а: конструктор вместо атрибутов инициализации, реализация IDisposable как TearDown.

### Что тестировать, а что – нет?

Одни говорят о необходимости покрытия кода на 100%, другие считают это лишней тратой ресурсов.  
Мне нравится такой подход: расчертите лист бумаги по оси X и Y, где X – алгоритмическая сложность, а Y – количество зависимостей. Ваш код можно разделить на 4 группы.  
![](https://habrastorage.org/storage2/177/ea7/e55/177ea7e5529adfb647db334db0e83cb0.png)

Рассмотрим сначала экстремальные случаи: простой код без зависимостей и сложный код с большим количеством зависимостей.

1.  **Простой код без зависимостей.** Скорее всего здесь и так все ясно. Его можно не тестировать.
2.  **Сложный код с большим количеством зависимостей.** Хм, если у вас есть такой код, тут пахнет God Object’ом и сильной связностью. Скорее всего, неплохо будет провести рефакторинг. Мы не станем покрывать этот код юнит-тестами, потому что перепишем его, а значит, у нас изменятся сигнатуры методов и появятся новые классы. Так зачем писать тесты, которые придется выбросить? Хочу оговориться, что для проведения такого рода рефакторинга нам все же нужно тестирование, но лучше воспользоваться более высокоуровневыми _приемочными тестами_. Мы рассмотрим этот случай отдельно.

Что у нас остается:

1.  **Cложный код без зависимостей.** Это некие алгоритмы или бизнес-логика. Отлично, это важные части системы, тестируем их.
2.  **Не очень сложный код с зависимостями.** Этот код связывает между собой разные компоненты. Тесты важны, чтобы уточнить, как именно должно происходить взаимодействие. Причина потери Mars Climate Orbiter 23 сентября 1999 года заключалась в программно-человеческой ошибке: одно подразделение проекта считало «в дюймах», а другое – «в метрах», и прояснили это уже после потери аппарата. Результат мог быть другим, если бы команды протестировали «швы» приложения.

### Придерживайтесь единого стиля написания тела теста

Отлично зарекомендовал себя подход AAA _(arrange, act, assert)_ . Вернемся к примеру с калькулятором:

    class CalculatorTests
    {
    	public void Sum_2Plus5_7Returned()
    	{
    		// arrange
    		var calc = new Calculator();
    	
    		// act
    		var res = calc.Sum(2,5);
    
    		// assert
    		Assert.AreEqual(7, res);	
    	}
    }
    

Такая форма записи гораздо легче читается, чем

    class CalculatorTests
    {
    	public void Sum_2Plus5_7Returned()
    	{
    		Assert.AreEqual(7, new Calculator().sum(2,5));	
    	}
    }
    

А значит, этот код проще поддерживать.

### Тестируйте одну вещь за один раз

**Каждый тест должен проверять только одну вещь.** Если процесс слишком сложен (например, покупка в интернет магазине), разделите его на несколько частей и протестируйте их отдельно.  
Если вы не будете придерживаться этого правила, ваши тесты станут нечитаемыми, и вскоре вам окажется очень сложно их поддерживать.

### Борьба с зависимостями

До сих пор мы тестировали калькулятор. У него совсем нет зависимостей. В современных бизнес-приложениях количество таких классов, к сожалению, мало.  
Рассмотрим такой пример.

    public class AccountManagementController : BaseAdministrationController
    {
    	#region Vars
    
    	private readonly IOrderManager _orderManager;
            private readonly IAccountData _accountData;
            private readonly IUserManager _userManager;
            private readonly FilterParam _disabledAccountsFilter;
    
            #endregion
    
            public AccountManagementController()
            {
                _oms = OrderManagerFactory.GetOrderManager();
                _accountData = _ orderManager.GetComponent<IAccountData>();
                _userManager = UserManagerFactory.Get();
                _disabledAccountsFilter = new FilterParam("Enabled", Expression.Eq, true);
            }
    }
    

Фабрика в этом примере берет данные о конкретной реализации _AccountData_ из файла конфигурации, что нас абсолютно не устраивает. Мы же не хотим поддерживать зоопарк файлов \*.config. Более того, настоящие реализации могут зависеть от базы данных. Если мы продолжим в том же духе, то перестанем тестировать только методы контроллера и начнем вместе с ними тестировать другие компоненты системы. Как мы помним, это называется _интеграционным тестированием_.  
Чтобы не тестировать все вместе, мы подсунем фальшивую реализацию _(fake)_.  
Перепишем наш класс так:

    public class AccountManagementController : BaseAdministrationController
    {
            #region Vars
    
            private readonly IOrderManager _oms;
            private readonly IAccountData _accountData;
            private readonly IUserManager _userManager;
            private readonly FilterParam _disabledAccountsFilter;
    
            #endregion
    
            public AccountManagementController()
            {
                _oms = OrderManagerFactory.GetOrderManager();
                _accountData = _oms.GetComponent<IAccountData>();
                _userManager = UserManagerFactory.Get();
                _disabledAccountsFilter = new FilterParam("Enabled", Expression.Eq, true);
            }
    
            /// <summary>
            /// For testability
            /// </summary>
            /// <param name="accountData"></param>
            /// <param name="userManager"></param>
            public AccountManagementController(
                IAccountData accountData,
                IUserManager userManager)
            {
                _accountData = accountData;
                _userManager = userManager;
                _disabledAccountsFilter = new FilterParam("Enabled", Expression.Eq, true);
            }
    }
    

Теперь у контроллера появилась новая точка входа, и мы можем передать туда другие реализации интерфейсов.

### Fakes: stubs & mocks

Мы переписали класс и теперь можем подсунуть контроллеру другие реализации зависимостей, которые не станут лезть в базу, смотреть конфиги и т.д. Словом, будут делать только то, что от них требуется. Разделяем и властвуем. Настоящие реализации мы должны протестировать отдельно в своих собственных тестовых классах. Сейчас мы тестируем только контроллер.

**Выделяют два типа подделок: стабы (stubs) и моки (mock).**  
Часто эти понятия путают. Разница в том, что стаб ничего не проверяет, а лишь имитирует заданное состояние. А мок – это объект, у которого есть ожидания. Например, что данный метод класса должен быть вызван определенное число раз. Иными словами, ваш тест никогда не сломается из-за «стаба», а вот из-за мока может.  
С технической точки зрения это значит, что используя стабы в Assert мы проверяем состояние тестируемого класса или результат выполненного метода. При использовании мока мы проверяем, соответствуют ли ожидания мока поведению тестируемого класса.

#### Стаб

#### ![](https://habrastorage.org/storage2/95a/409/842/95a40984251f9529238b2e48c61e79f2.png)

    [Test]
    public void LogIn_ExisingUser_HashReturned()
    {
    	// Arrange
    	OrderProcessor = Mock.Of<IOrderProcessor>();
    	OrderData = Mock.Of<IOrderData>();
    	LayoutManager = Mock.Of<ILayoutManager>();
    	NewsProvider = Mock.Of<INewsProvider>();
    
    	Service = new IosService(
    		UserManager,
    		AccountData,
    		OrderProcessor,
    		OrderData,
    		LayoutManager,
    		NewsProvider);
    	
    	// Act
    	var hash = Service.LogIn("ValidUser", "Password");
    
    	// Assert
    	Assert.That(!string.IsNullOrEmpty(hash));
    }
    

#### Мок

#### ![](https://habrastorage.org/storage2/92d/add/11c/92dadd11ca7c689b6cc19e1f040c1888.png)

    [Test]
    public void Create_AddAccountToSpecificUser_AccountCreatedAndAddedToUser()
    {
        // Arrange
        var account = Mock.Of<AccountViewModel>();
                
        // Act
        _controller.Create(1, account);
    
        // Assert
        _accountData.Verify(m => m.CreateAccount(It.IsAny<IAccount>()), Times.Exactly(1));
        _accountData.Verify(m => m.AddAccountToUser(It.IsAny<int>(), It.IsAny<int>()), Times.Once());
    }
    

### Тестирование состояния и тестирование поведения

Почему важно понимать, казалось бы, незначительную разницу между моками и стабами? Давайте представим, что нам нужно протестировать автоматическую систему полива. Можно подойти к этой задаче двумя способами:

#### Тестирование состояния

Запускаем цикл (12 часов). И через 12 часов проверяем, хорошо ли политы растения, достаточно ли воды, каково состояние почвы и т.д.

#### Тестирование взаимодействия

Установим датчики, которые будут засекать, когда полив начался и закончился, и сколько воды поступило из системы.  
Стабы используются при тестировании состояния, а моки – взаимодействия. **Лучше использовать не более одного мока на тест**. Иначе с высокой вероятностью вы нарушите принцип «тестировать только одну вещь». При этом в одном тесте может быть сколько угодно стабов или же мок и стабы.

### Изоляционные фреймвоки

Мы могли бы реализовывать моки и стабы самостоятельно, но есть несколько причин, почему я не советую делать это:

*   Велосипеды уже написаны до нас
*   Многие интерфейсы не так просто реализовать с полпинка
*   Наши самописные подделки могут содержать ошибки
*   Это дополнительный код, который придется поддерживать

В примере выше я использовал фреймворк [Moq](http://code.google.com/p/moq/) для создания моков и стабов. Довольно распространен фреймворк [Rhino Mocks](http://www.hibernatingrhinos.com/oss/rhino-mocks). Оба фреймворка — бесплатные. На мой взгляд, они практически эквивалентны, но Moq субъективно удобнее.

На рынке есть также два коммерческих фреймворка: _TypeMock Isolator_ и _Microsoft Moles_. На мой взгляд они обладают чрезмерными возможностями подменять невиртуальные и статические методы. Хотя при работе с унаследованным кодом это и может быть полезно, ниже я опишу, почему все-таки не советую заниматься подобными вещами.

Шоукейсы перечисленных изоляционных фреймворков можно посмотреть [тут](http://code.google.com/p/mocking-frameworks-compare/). А информацию по техническим аспектам работы с ними легко найти на Хабре.

### Тестируемая архитектура

Вернемся к примеру с контроллером.

    public AccountManagementController(
        IAccountData accountData,
        IUserManager userManager)
    {
        _accountData = accountData;
        _userManager = userManager;
        _disabledAccountsFilter = new FilterParam("Enabled", Expression.Eq, true);
    }
    

Здесь мы отделались «малой кровью». К сожалению, не всегда все бывает так просто. Давайте рассмотрим основные случаи, как мы можем внедрить зависимости:

#### Инъекция в конструктор

Добавляем дополнительный конструктор или заменяем текущий (зависит от того, как вы создаете объекты в вашем приложении, используете ли IOC-контейнер). Этим подходом мы воспользовались в примере выше.

#### Инъекция в фабрику

Setter можно дополнительно «спрятать» от основного приложения, если выделить интерфейс IUserManagerFactory и работать в продакшн-коде по интерфейсной ссылке.

    public class UserManagerFactory
    {
        private IUserManager _instance;
    
        /// <summary>
        /// Get UserManager instance
        /// </summary>
        /// <returns>IUserManager with configuration from the configuration file</returns>
        public IUserManager Get()
        {
            return _instance ?? Get(UserConfigurationSection.GetSection());
        }
    
        private IUserManager Get(UserConfigurationSection config)
        {
            return _instance ?? (_instance = Create(config));
        }
    
        /// <summary>
        /// For testing purposes only!
        /// </summary>
        /// <param name="userManager"></param>
        public void Set(IUserManager userManager)
        {
            _instance = userManager;
        }
    }
    

  

#### Подмена фабрики

Вы можете подменить всю фабрику целиком. Это потребует выделение интерфейса или создание виртуальной функции, создание объектов. После этого вы сможете переопределить фабричные методы так, чтобы они возвращали ваши подделки.

#### Переопределение локального фабричного метода

Если зависимости инстанцируются прямо в коде явным образом, то самый простой путь – выделить фабричный protected-метод CreateObjectName() и переопределить его в классе-наследнике. После этого тестируйте класс-наследник, а не ваш первоначально тестируемый класс.  
Например, мы решили написать расширяемый калькулятор (со сложными действиями) и начали выделять новый слой абстракции.

    public class Calculator
    {
        public double Multipy(double a, double b)
        {
            var multiplier = new Multiplier();
            return multiplier.Execute(a, b);
        }
    }
    
    public interface IArithmetic
    {
        double Execute(double a, double b);
    }
    
    public class Multiplier : IArithmetic
    {
        public double Execute(double a, double b)
        {
            return a * b;
        }
    }
    

Мы не хотим тестировать класс _Multiplier_, для него будет отдельный тест. Перепишем код так:

    public class Calculator
    {
        public double Multipy(double a, double b)
        {
            var multiplier = CreateMultiplier();
            return multiplier.Execute(a, b);
        }
    
        protected virtual IArithmetic CreateMultiplier()
        {
            var multiplier = new Multiplier();
            return multiplier;
        }
    }
    
    public class CalculatorUnderTest : Calculator
    {
        protected override IArithmetic CreateMultiplier()
        {
            return new FakeMultiplier();
        }
    }
    
    public class FakeMultiplier : IArithmetic
    {
        public double Execute(double a, double b)
        {
            return 5;
        }
    }
    

Код намеренно упрощен, чтобы акцентировать внимание именно на иллюстрации способа. В реальной жизни вместо калькулятора, скорее всего, будут DataProvider’ы, UserManager’ы и другие сущности с гораздо более сложной логикой.

#### Тестируемая архитектура VS OOP

Многие разработчики начинают жаловаться, дескать «этот ваш тестируемый дизайн» нарушает инкапсуляцию, открывает слишком много. Я думаю, что существует только две причины, когда это может вас беспокоить:

##### Серьезные требования к безопасности

Это значит, что у вас серьезная криптография, бинарники упакованы, и все обвешано сертификатами.  
Даже если так, скорее всего, вы сможете найти компромиссное решение. Например, в .NET вы можете использовать internal-методы и атрибут [\[InternalsVisibleTo\]](http://msdn.microsoft.com/ru-ru/library/system.runtime.compilerservices.internalsvisibletoattribute.aspx), чтобы дать доступ к тестируемым методам из ваших тестовых сборок.

##### Производительность

Существует ряд задач, когда архитектурой приходится жертвовать в угоду производительности, и для кого-то это становится поводом отказаться от тестирования. В моей практике докинуть сервер/проапгрейдить железо всегда было дешевле, чем писать нетестируемый код. Если у вас есть критический участок, вероятно, стоит переписать его на более низком уровне. Ваше приложение на C#? Возможно, есть смысл собрать одну неуправляемую сборку на С++.

Вот несколько принципов, которые помогают писать тестируемый код:

*   Мыслите интерфейсами, а не классами, тогда вы всегда сможете легко подменять настоящие реализации подделками в тестовом коде
*   Избегайте прямого инстанцирования объектов внутри методов с логикой. Используйте фабрики или _dependency injection_. В этом случае использование IOC-контейнера в проекте может сильно упростить вам работу.
*   Избегайте прямого вызова статических методов
*   Избегайте конструкторов, которые содержат логику: вам сложно будет это протестировать.

Работа с унаследованным кодом
-----------------------------

Под «унаследованным» мы будем понимать код без тестов. Качество такого кода может быть разным. Несколько советов, как можно покрыть его тестами.

### Архитектура тестируема

Нам повезло, прямых созданий классов и мясорубки нет, а принципы SOLID соблюдаются. Нет ничего проще – создаем тестовые проекты, и шаг за шагом покрываем приложение, используя принципы, описанные в статье. В крайнем случае, нам придется добавить пару сеттеров для фабрик и выделить несколько интерфейсов.

### Архитектура не тестируема

У нас есть жесткие связи, костыли и прочие радости жизни. Нам предстоит рефакторинг. Как правильно проводить комплексный рефакторинг – тема, выходящая далеко за рамки этой статьи.  
Стоит выделить основное правило. Если вы не меняете интерфейсов – все просто, методика идентична. А вот если вы задумали большие перемены, следует составить граф зависимостей и разбить ваш код на отдельные более мелкие подсистемы (надеюсь, что это возможно). В идеале должно получиться примерно так: ядро, модуль #1, модуль #2 и т.д.  
После этого выберите жертву. Только не начинайте с ядра. Возьмите сначала что-то поменьше: то, что вы способны отрефакторить за разумное время. Покрывайте эту подсистему интеграционными и/или приемочными тестами. А когда закончите, сможете покрыть эту часть юнит-тестами. Рано или поздно, шаг за шагом, вы должны преуспеть.  
Будьте готовы, что сделать это быстро

~скорее всего~

не получится. Вам придется проявить волевые качества.

Поддержка тестов
----------------

![](https://habrastorage.org/storage2/b51/49e/b95/b5149eb9594de7513ca2c79e1d1a0f41.png)

Не относитесь к своим тестам как к второсортному коду. Многие начинающие разработчики ошибочно полагают, что DRY, KISS и все остальное – это для продакшна. А в тестах допустимо все. **Это не верно. Тесты – такой-же код.** Разница только в том, что у тестов другая цель – обеспечить качество вашего приложения. Все принципы, применямые в разработке продакшн-кода могут и должны применяться при написании тестов.  
Есть всего три причины, почему тест перестал проходить:

1.  Ошибка в продакшн-коде: это баг, его нужно завести в баг-трекере и починить.
2.  Баг в тесте: видимо, продакшн-код изменился, а тест написан с ошибкой (например, тестирует слишком много или не то, что было нужно). Возможно, что раньше он проходил ошибочно. Разберитесь и почините тест.
3.  Смена требований. Если требования изменились слишком сильно – тест должен упасть. Это правильно и нормально. Вам нужно разобраться с новыми требованиями и исправить тест. Или удалить, если он больше не актуален.

Уделяйте внимание поддержке ваших тестов, чините их вовремя, удаляйте дубликаты, выделяйте базовые классы и развивайте API тестов. Можно завести шаблонные базовые тестовые классы, которые обязывают реализовать набор тестов (например CRUD). Если делать это регулярно, то вскоре это не будет занимать много времени.

Как «измерить» прогресс
-----------------------

Для измерения успешности внедрения юнит-тестов в вашем проекте следует использовать две метрики:

1.  Количество багов в новых релизах (в т.ч. и регрессии)
2.  Покрытие кода

Первая показывает, есть ли у наших действий результат, или мы впустую расходуем время, которое могли бы потратить на фичи. Вторая – как много нам еще предстоит сделать.

Наиболее популярные тулзы для измерения покрытия кода на .NET платформе это:

*   NCover
*   dotTrace
*   встроенный в студию Test Coverage

Test First?
-----------

![](https://habrastorage.org/storage2/a4f/4a2/11e/a4f4a211e0a89c703b0741ed55d56f65.png)

Я умышленно не касался этой темы до самого конца. С моей точки зрения Test First – хорошая практика, обладающая рядом неоспоримых преимуществ. Однако, по тем или иным причинам, иногда я отступаю от этого правила и пишу тесты после того, как готов код.

На мой взгляд, «как писать тесты» гораздо важнее, чем «когда это делать». Делайте, как вам удобно, но не забывайте: если вы начинаете с тестов, то получаете архитектуру «в придачу». Если вы сначала пишете код, вам возможно, придется его менять, чтобы сделать тестируемым.

Почитать на тему
----------------

Отличную подборку ссылок и книг по теме можно найти в [этой статье на Хабре](http://habrahabr.ru/post/136049/). Особенно рекомендую книгу The Art of Unit Testing. Я читал первое издание. Оказывается, вышло уже и второе.


[Source](https://habr.com/ru/post/169381/)